#!/usr/bin/env bash
# Sophia Dev CLI - unified wrapper (tools + services)

set -euo pipefail

ROOT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
MANAGER="$ROOT_DIR/unified-system-manager.sh"

# Ensure Opencode is invokable even if PATH is missing
export PATH="$HOME/.opencode/bin:$PATH"

usage() {
  cat <<EOF
Sophia Dev CLI

Usage: ./dev <command> [args]

Core:
  start | stop | restart     Manage all services (LiteLLM + MCP)
  status | health            Show status / quick health
  logs | clean               Tail logs / kill orphans + clear PIDs

MCP:
  mcp start | stop | status  Control MCP servers / port check

LiteLLM:
  litellm start | stop       Control LiteLLM proxy

Tools:
  claude|cl <args>           Claude Code CLI passthrough
  opencode|oc <args>         Opencode CLI via repo shim
  codex|cx <args>            Codex CLI passthrough
  cursor                     Open current repo in Cursor
  ai <subcmd>                Unified AI router (see: bin/ai)

BI:
  bi --query "..." [--run]   Run BI helper pipeline (Codex→SQL, Gemini→analysis, Claude→summary)

Models:
  models show                Show centralized model aliases/usecases
  models set alias <a> <m>   Set alias → model mapping
  models set usecase <u> <a> Set usecase → alias mapping

Tests:
  test                       Run integration tests
  check                      Preflight check (Redis, MCP, LiteLLM, tools)

Info:
  info                       Show configuration summary
  help                       Show this help
EOF
}

cmd="${1:-}"; shift || true

case "$cmd" in
  start|stop|restart|status|health|logs|clean)
    exec "$MANAGER" "$cmd"
    ;;
  mcp)
    sub=${1:-}; shift || true
    case "$sub" in
      start) exec "$MANAGER" mcp-start ;;
      stop)  exec "$MANAGER" mcp-stop  ;;
      status)
        ports=(8081 8082 8084)
        names=("Memory" "Filesystem" "Git")
        for i in ${!ports[@]}; do
          if (command -v nc >/dev/null && nc -z localhost "${ports[$i]}" >/dev/null 2>&1) || \
             (command -v lsof >/dev/null && lsof -Pi :"${ports[$i]}" -sTCP:LISTEN -t >/dev/null 2>&1); then
            printf "✅ MCP %-10s on %d\n" "${names[$i]}" "${ports[$i]}"
          else
            printf "❌ MCP %-10s down (port %d)\n" "${names[$i]}" "${ports[$i]}"
          fi
        done
        ;;
      *) usage; exit 1;;
    esac
    ;;
  claude|cl)
    # Prefer repo shim over global CLAUDE tools
    if [ -x "$ROOT_DIR/bin/claude" ]; then
      CLAUDE_BIN="$ROOT_DIR/bin/claude"
    else
      command -v claude >/dev/null 2>&1 || { echo "claude CLI not found" >&2; exit 127; }
      CLAUDE_BIN="claude"
    fi

    # Build safe args: map legacy flags and inject local settings if available
    CLAUDE_ARGS=()
    ADD_PRINT=false
    HAVE_SETTINGS=false
    HAVE_PERMISSION_MODE=false
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --mode)
          # Map legacy flag to current CLI arg
          CLAUDE_ARGS+=("--permission-mode")
          shift
          # Preserve the mode value if provided
          if [[ -n "${1:-}" ]]; then
            CLAUDE_ARGS+=("$1")
            [[ "$1" == "plan" ]] && ADD_PRINT=true
            shift || true
          fi
          ;;
        --permission-mode)
          HAVE_PERMISSION_MODE=true
          CLAUDE_ARGS+=("$1")
          shift
          if [[ -n "${1:-}" ]]; then
            CLAUDE_ARGS+=("$1")
            [[ "$1" == "plan" ]] && ADD_PRINT=true
            shift || true
          fi
          ;;
        --settings)
          HAVE_SETTINGS=true
          CLAUDE_ARGS+=("$1")
          shift
          if [[ -n "${1:-}" ]]; then CLAUDE_ARGS+=("$1"); shift || true; fi
          ;;
        --print|-p)
          # Respect existing print flag
          ADD_PRINT=false
          CLAUDE_ARGS+=("$1")
          shift
          # If -p has an inline prompt argument, preserve it
          if [[ "$1" != -* && -n "${1:-}" ]]; then CLAUDE_ARGS+=("$1"); shift || true; fi
          ;;
        *)
          CLAUDE_ARGS+=("$1")
          shift
          ;;
      esac
    done

    # If local settings exist and not explicitly provided, include them
    if [[ -f "$ROOT_DIR/.claude/settings.local.json" && "$HAVE_SETTINGS" = false ]]; then
      CLAUDE_ARGS+=("--settings" "$ROOT_DIR/.claude/settings.local.json")
    fi

    # If a local MCP config exists and not explicitly provided, include it.
    # If MCP_TOKEN is set, dynamically generate a secure config with Authorization header.
    HAVE_MCP_CONFIG=false
    for a in "${CLAUDE_ARGS[@]}"; do [[ "$a" == "--mcp-config" ]] && HAVE_MCP_CONFIG=true; done
    if [[ "$HAVE_MCP_CONFIG" = false ]]; then
      if [[ -n "${MCP_TOKEN:-}" ]]; then
        # Generate a temp MCP config that injects Authorization header
        MCP_TMP_CFG="${SAFE_HOME}/.claude-mcp-config.json"
        mkdir -p "${SAFE_HOME}" 2>/dev/null || true
        cat >"${MCP_TMP_CFG}" <<EOF
{
  "servers": {
    "memory": {"baseUrl": "http://localhost:8081", "headers": {"Authorization": "Bearer ${MCP_TOKEN}"}},
    "filesystem": {"baseUrl": "http://localhost:8082", "headers": {"Authorization": "Bearer ${MCP_TOKEN}"}},
    "git": {"baseUrl": "http://localhost:8084", "headers": {"Authorization": "Bearer ${MCP_TOKEN}"}}
  }
}
EOF
        CLAUDE_ARGS+=("--mcp-config" "${MCP_TMP_CFG}")
      elif [[ -f "$ROOT_DIR/.claude/mcp.local.json" ]]; then
        CLAUDE_ARGS+=("--mcp-config" "$ROOT_DIR/.claude/mcp.local.json")
      fi
    fi

    # For plan mode, default to non-interactive output unless user already provided --print
    if [[ "$ADD_PRINT" = true ]]; then
      # Only add --print if not already present
      PRINT_SET=false
      for a in "${CLAUDE_ARGS[@]}"; do [[ "$a" == "--print" || "$a" == "-p" ]] && PRINT_SET=true; done
      [[ "$PRINT_SET" = false ]] && CLAUDE_ARGS+=("--print")
    fi

    # Sandbox-safe HOME fallback: if $HOME is not writable, redirect to repo-local
    SAFE_HOME="$HOME"
    if ! ( : >"$HOME/.claude.sanity" ) >/dev/null 2>&1; then
      SAFE_HOME="$ROOT_DIR/.home"
      mkdir -p "$SAFE_HOME" 2>/dev/null || true
    fi

    HOME="$SAFE_HOME" exec "$CLAUDE_BIN" "${CLAUDE_ARGS[@]}"
    ;;
  opencode|oc)
    exec "$ROOT_DIR/bin/opencode" "$@"
    ;;
  codex|cx)
    command -v codex >/dev/null 2>&1 || { echo "codex CLI not found" >&2; exit 127; }
    exec codex "$@"
    ;;
  cursor)
    command -v cursor >/dev/null 2>&1 || { echo "cursor CLI not found" >&2; exit 127; }
    exec cursor .
    ;;
  ai)
    exec "$ROOT_DIR/bin/ai" "$@"
    ;;
  test)
    if [ -x "$ROOT_DIR/integration-test.sh" ]; then
      exec "$ROOT_DIR/integration-test.sh"
    elif [ -x "$ROOT_DIR/test-integration.sh" ]; then
      exec "$ROOT_DIR/test-integration.sh"
    else
      echo "No integration test script found" >&2
      exit 1
    fi
    ;;
  check)
    # Preflight: Redis, MCP, LiteLLM, Tools
    echo "Preflight Check"
    echo "================"
    # Env
    if [ -f "$HOME/sophia-intel-ai/.env.master" ]; then
      echo "Env: using .env.master"
    elif [ -f "$HOME/.config/sophia/env" ]; then
      echo "Env: using ~/.config/sophia/env"
    else
      echo "Env: not found (.env.master or ~/.config/sophia/env)"
    fi
    # Redis quick check (best-effort)
    if command -v redis-cli >/dev/null 2>&1; then
      if redis-cli ping >/dev/null 2>&1; then echo "Redis: ✅ ping ok"; else echo "Redis: ⚠️ no response"; fi
    else
      echo "Redis: (redis-cli not found)"
    fi
    # MCP health
    for port in 8081 8082 8084; do
      name=""
      [ "$port" = "8081" ] && name=Memory
      [ "$port" = "8082" ] && name=Filesystem
      [ "$port" = "8084" ] && name=Git
      if curl -s --max-time 2 "http://localhost:$port/health" >/dev/null 2>&1; then
        echo "MCP $name: ✅ /health ok (:$port)"
      else
        if (command -v nc >/dev/null && nc -z localhost "$port" >/dev/null 2>&1) || \
           (command -v lsof >/dev/null && lsof -Pi :"$port" -sTCP:LISTEN -t >/dev/null 2>&1); then
          echo "MCP $name: ⚠️ port listening but /health no response (:$port)"
        else
          echo "MCP $name: ❌ not listening (:$port)"
        fi
      fi
    done
    # LiteLLM
    if (command -v nc >/dev/null && nc -z localhost 4000 >/dev/null 2>&1) || \
       (command -v lsof >/dev/null && lsof -Pi :4000 -sTCP:LISTEN -t >/dev/null 2>&1); then
      if curl -s --max-time 3 http://localhost:4000/v1/models ${LITELLM_MASTER_KEY:+-H "Authorization: Bearer ${LITELLM_MASTER_KEY}"} >/dev/null 2>&1; then
        echo "LiteLLM: ✅ v1/models responding"
        # Optional cheap chat probe (fast + low tokens)
        if command -v jq >/dev/null 2>&1; then
          RESP=$(curl -s --max-time 5 http://localhost:4000/v1/chat/completions \
            -H 'Content-Type: application/json' ${LITELLM_MASTER_KEY:+-H "Authorization: Bearer ${LITELLM_MASTER_KEY}"} \
            -d '{"model":"cheap","messages":[{"role":"user","content":"say ok"}],"max_tokens":5}' 2>/dev/null || true)
          if echo "$RESP" | jq -e '.choices[0].message.content' >/dev/null 2>&1; then
            echo "LiteLLM: ▸ chat probe ✅"
          else
            echo "LiteLLM: ▸ chat probe ⚠️"
          fi
        fi
      else
        echo "LiteLLM: ⚠️ port open, models not responding"
      fi
    else
      echo "LiteLLM: ❌ not running (port 4000)"
    fi

    # MCP memory write/read (best-effort)
    if (command -v nc >/dev/null && nc -z localhost 8081 >/dev/null 2>&1) || \
       (command -v lsof >/dev/null && lsof -Pi :8081 -sTCP:LISTEN -t >/dev/null 2>&1); then
      echo "MCP Memory: attempting write/read test"
      AUTH_HEADER=""
      if [ -n "${MCP_TOKEN:-}" ]; then AUTH_HEADER="-H 'Authorization: Bearer ${MCP_TOKEN}'"; fi
      # shellcheck disable=SC2086
      curl -s -X POST http://localhost:8081/sessions/dev-check/memory \
        -H 'Content-Type: application/json' ${AUTH_HEADER} \
        -d '{"content":"dev-check","role":"user","metadata":{"source":"dev-check"}}' >/dev/null 2>&1 && echo "  ▸ write: ✅" || echo "  ▸ write: ❌"
      # shellcheck disable=SC2086
      if curl -s ${AUTH_HEADER} http://localhost:8081/sessions/dev-check/memory >/dev/null 2>&1; then
        echo "  ▸ read:  ✅"
      else
        echo "  ▸ read:  ❌"
      fi
    fi
    # Tools
    command -v opencode >/dev/null 2>&1 && echo "Opencode: ✅ in PATH" || echo "Opencode: ⚠️ not in PATH (use ./dev opencode)"
    command -v litellm  >/dev/null 2>&1 && echo "litellm: ✅ available" || echo "litellm: ⚠️ not installed"
    command -v python3  >/dev/null 2>&1 && echo "python3: ✅ available" || echo "python3: ❌ missing"
    ;;
  bi)
    # Minimal BI helper pipeline: Codex→SQL, Gemini→analysis, Claude→summary
    Q=""
    RUN="false"
    while [ $# -gt 0 ]; do
      case "$1" in
        --query)
          shift; Q=${1:-};;
        --run)
          RUN="true";;
      esac
      shift || true
    done
    if [ -z "$Q" ]; then
      echo "Usage: ./dev bi --query \"Show me sales pipeline trends...\" [--run]" >&2
      exit 1
    fi
    echo "BI Query: $Q"
    echo "Plan: Codex (SQL) → Gemini (analysis) → Claude (executive summary)"
    if [ "$RUN" = "true" ]; then
      echo "Running pipeline..."
      # 1) Codex: propose SQL (printed)
      if command -v codex >/dev/null 2>&1; then
        echo "--- Codex (SQL suggestion) ---"
        codex "Generate SQL for: $Q. Respond with SQL only." || true
      else
        echo "codex CLI not found; skipping"
      fi
      # 2) Gemini: analyze patterns
      if command -v litellm-cli >/dev/null 2>&1; then
        echo "--- Gemini (analysis) ---"
        litellm-cli chat --model gemini-1.5-pro -p "Analyze business patterns for: $Q. Focus on trends and anomalies." || true
      else
        echo "litellm-cli not found; skipping Gemini"
      fi
      # 3) Claude: executive summary
      if command -v claude >/dev/null 2>&1; then
        echo "--- Claude (executive summary) ---"
        claude -p "Create an executive summary for the following BI question: $Q. Include actionable insights and next steps." || true
      else
        echo "claude CLI not found; skipping"
      fi
    else
      echo "Use --run to execute the pipeline. Otherwise, run sub-steps via './dev ai' or individual CLIs."
    fi
    ;;
  info)
    echo "Multi-Tool Development Environment"
    echo "=================================="
    echo "MCP Servers:"
    echo "  Memory:     http://localhost:8081"
    echo "  Filesystem: http://localhost:8082"
    echo "  Git:        http://localhost:8084"
    echo ""
    echo "Tools Available:"
    command -v claude  >/dev/null 2>&1 && echo "  ✓ Claude Code (claude)"  || echo "  • Claude Code not found"
    command -v opencode>/dev/null 2>&1 && echo "  ✓ Opencode (opencode)"   || echo "  • Opencode not in PATH (use ./dev opencode)"
    command -v codex   >/dev/null 2>&1 && echo "  ✓ Codex (codex)"         || echo "  • Codex not found"
    echo ""
    echo "Model Map (from config/models.json):"
    if [ -x "$ROOT_DIR/bin/llm-models" ]; then
      if command -v jq >/dev/null 2>&1; then
        echo "  Aliases:"
        jq -r '.aliases | to_entries[] | "    \(.key) -> \(.value)"' config/models.json 2>/dev/null || true
        echo "  Usecases:"
        jq -r '.usecases | to_entries[] | "    \(.key) -> alias:\(.value)"' config/models.json 2>/dev/null || true
        echo "  CLI Defaults:"
        jq -r '.cli_defaults | to_entries[] | "    \(.key) -> alias:\(.value)"' config/models.json 2>/dev/null || true
      else
        echo "  (Install jq for pretty view)"
        echo "  Run: ./dev models show"
      fi
    else
      echo "  (llm-models tool not found)"
    fi
    ;;
  models)
    CMD="$ROOT_DIR/bin/llm-models"
    if [ ! -x "$CMD" ]; then echo "llm-models tool missing" >&2; exit 1; fi
    exec "$CMD" "$@"
    ;;
  ""|help|-h|--help)
    usage
    ;;
  *)
    echo "Unknown command: $cmd" >&2
    usage
    exit 1
    ;;
esac
