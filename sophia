#!/usr/bin/env python3
"""
Sophia Intel AI - Master CLI (Python wrapper + service delegator)

Goals:
- Preserve single-user .env.master behavior (as requested).
- Consolidate keys/secrets handling so ./sophia aligns with ./dev.
- Keep things running and simple for a single developer.

Behavior:
- Load environment only from repo .env.master (single source of truth).
- Apply dev-friendly defaults (MCP_DEV_BYPASS=true, REDIS_URL local, LITELLM_MASTER_KEY default).
- If invoked with a service command (start/stop/restart/status/health/logs/clean),
  delegate to the unified-system-manager.sh for consistent process control.
- If invoked without a service command, dispatch to sophia_cli.cli as the primary entrypoint.
"""
from __future__ import annotations

import os
import sys
import subprocess
from pathlib import Path
from typing import Iterable, List


def _parse_env_lines(lines: Iterable[str]) -> dict[str, str]:
    env: dict[str, str] = {}
    for raw in lines:
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        if "=" not in line:
            continue
        key, val = line.split("=", 1)
        key = key.strip()
        val = val.strip().strip('"').strip("'")
        if key:
            env[key] = val
    return env


def load_env_files() -> None:
    """Single-source env loader: only repo-local .env.master. No fallbacks, no prompts."""
    repo_dir = Path(__file__).parent
    env_path = repo_dir / ".env.master"
    if env_path.exists() and env_path.is_file():
        try:
            content = env_path.read_text(encoding="utf-8", errors="ignore").splitlines()
            parsed = _parse_env_lines(content)
            for k, v in parsed.items():
                os.environ.setdefault(k, v)
        except Exception:
            # Silently continue; downstream services may still start
            pass

    # Dev-friendly defaults to align with ./dev and the unified manager
    os.environ.setdefault("MCP_DEV_BYPASS", "true")
    os.environ.setdefault("REDIS_URL", "redis://localhost:6379/1")
    os.environ.setdefault("LITELLM_MASTER_KEY", "sk-litellm-master-2025")

    # Wiring for Grok CLI: prefer XAI_API_KEY if GROK_API_KEY not set
    if not os.environ.get("GROK_API_KEY"):
        xai = os.environ.get("XAI_API_KEY")
        if xai:
            os.environ["GROK_API_KEY"] = xai
    # Sensible default model for fast coding
    os.environ.setdefault("GROK_MODEL", "grok-code-fast-1")


def delegate_to_manager(args: List[str]) -> int:
    """
    Delegate service management commands to the unified-system-manager.sh script.
    """
    repo_dir = Path(__file__).parent
    manager = repo_dir / "unified-system-manager.sh"
    if not manager.exists():
        print("[ERROR] unified-system-manager.sh not found", file=sys.stderr)
        return 1
    # Make sure it's executable
    try:
        manager.chmod(manager.stat().st_mode | 0o111)
    except Exception:
        pass

    # Pass-through args directly (manager supports: start/stop/restart/status/health/logs/clean)
    result = subprocess.run([str(manager), *args], env=os.environ)
    return result.returncode


def run_validator() -> int:
    """
    Fallback for `./sophia test` to give a quick validation path without changing env policy.
    """
    validator = Path(__file__).parent / "scripts" / "validate_startup_guide.sh"
    if validator.exists():
        try:
            validator.chmod(validator.stat().st_mode | 0o111)
        except Exception:
            pass
        return subprocess.run(["bash", str(validator)], env=os.environ).returncode
    # If validator not present, degrade to manager's health
    return delegate_to_manager(["health"])


def main() -> None:
    load_env_files()

    # Service commands we delegate to the manager
    service_cmds = {
        "start", "stop", "restart", "status", "health", "logs", "clean"
    }

    if len(sys.argv) > 1:
        cmd = sys.argv[1]
        rest = sys.argv[2:]

        if cmd in service_cmds:
            rc = delegate_to_manager([cmd, *rest])
            sys.exit(rc)

        if cmd == "studio":
            # Launch the Studio (Next.js dev) in ./sophia-intel-app if available
            app_dir = Path(__file__).parent / "sophia-intel-app"
            if not app_dir.exists():
                print("[ERROR] app/ directory not found. Studio not available.")
                sys.exit(1)
            pkg = app_dir / "package.json"
            if not pkg.exists():
                print("[ERROR] app/package.json not found. Cannot start Studio.")
                sys.exit(1)
            if (app_dir / "pnpm-lock.yaml").exists():
                runner = ["pnpm", "dev"]
            elif (app_dir / "yarn.lock").exists():
                runner = ["yarn", "dev"]
            else:
                runner = ["npm", "run", "dev"]
            print("[INFO] Starting Sophia Studio (Next.js dev)â€¦")
            try:
                rc = subprocess.call(runner, cwd=str(app_dir), env=os.environ)
                sys.exit(rc)
            except FileNotFoundError:
                print(f"[ERROR] Runner not found: {runner[0]}. Install it and retry.")
                sys.exit(1)

        if cmd == "exec":
            # Execute an arbitrary command as a child process inheriting the loaded env
            if not rest:
                print("Usage: ./sophia exec <command> [args...]")
                sys.exit(1)
            rc = subprocess.call(rest, env=os.environ)
            sys.exit(rc)

        if cmd == "test":
            rc = run_validator()
            sys.exit(rc)

    # Otherwise, dispatch to the unified CLI
    try:
      from sophia_cli.cli import cli  # type: ignore
    except Exception as e:
      # Provide a helpful message if CLI is not available
      print("[INFO] sophia_cli not available. Use './sophia start' to manage services or './dev' for dev tasks.")
      print(f"[DEBUG] Import error: {e}")
      sys.exit(0)

    cli()


if __name__ == "__main__":
    main()
